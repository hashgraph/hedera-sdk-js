import PrivateKey from "../../src/PrivateKey.js";
import PublicKey from "../../src/PublicKey.js";
import * as utf8 from "../../src/encoding/utf8.js";
import * as hex from "../../src/encoding/hex.js";
import Mnemonic from "../../src/Mnemonic.js";
import BadKeyError from "../../src/BadKeyError.js";
import { keystoreV1 } from "./keystore.js";

const keystorePassword = "Harriet Porber And The Bad Boy Parasaurolophus";
const privateKeystore =
    "302e020100300506032b6570042204204072d365d02199b5103336cf6a187578ffb6eba4ad6f8b2383c5cc54d00c4409";

// key from hedera-sdk-java tests, not used anywhere
const privKeyBytes = Uint8Array.of(
    -37,
    72,
    75,
    -126,
    -114,
    100,
    -78,
    -40,
    -15,
    44,
    -29,
    -64,
    -96,
    -23,
    58,
    11,
    -116,
    -50,
    122,
    -15,
    -69,
    -113,
    57,
    -55,
    119,
    50,
    57,
    68,
    -126,
    83,
    -114,
    16
);

const privateKey = PrivateKey.fromBytes(privKeyBytes);

const privKeyStr =
    "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10";
const privAndPubKeyStr =
    "db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7";
const rawPrivKeyStr =
    "db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10";

const pubKeyBytes = Uint8Array.of(
    -32,
    -56,
    -20,
    39,
    88,
    -91,
    -121,
    -97,
    -6,
    -62,
    38,
    -95,
    60,
    12,
    81,
    107,
    121,
    -98,
    114,
    -29,
    81,
    65,
    -96,
    -35,
    -126,
    -113,
    -108,
    -45,
    121,
    -120,
    -92,
    -73
);

const message = utf8.encode("hello, world");

const signature = new Uint8Array([
    157, 4, 191, 237, 123, 170, 151, 200, 13, 41, 166, 174, 72, 192, 216, 150,
    206, 132, 99, 167, 234, 12, 22, 25, 125, 85, 165, 99, 199, 57, 150, 239, 6,
    43, 42, 223, 80, 127, 65, 108, 16, 132, 34, 192, 49, 15, 198, 251, 33, 136,
    110, 17, 206, 61, 227, 233, 81, 215, 165, 96, 73, 116, 63, 7,
]);

// root key generated by the iOS wallet, not used anywhere
const iosWalletMnemonic =
    "tiny denial casual grass skull spare awkward indoor ethics dash enough flavor good daughter early hard rug staff capable swallow raise flavor empty angle";

// private key for "default account", should be index 0
const iosWalletPrivKey =
    "5f66a51931e8c99089472e0d70516b6272b94dd772b967f8221e1077f966dbda2b60cf7ee8cf10ecd5a076bffad9a7c7b97df370ad758c0f1dd4ef738e04ceb6";

const iosWalletKeyBytes = hex.decode(iosWalletPrivKey);
const iosWalletPrivKeyBytes = iosWalletKeyBytes.subarray(0, 32);
const iosWalletPubKeyBytes = iosWalletKeyBytes.subarray(32);

// root key generated by the Android wallet, also not used anywhere
const androidWalletMnemonic =
    "ramp april job flavor surround pyramid fish sea good know blame gate village viable include mixed term draft among monitor swear swing novel track";

// private key for "default account", should be index 0
const androidWalletPrivKey =
    "c284c25b3a1458b59423bc289e83703b125c8eefec4d5aa1b393c2beb9f2bae66188a344ba75c43918ab12fa2ea4a92960eca029a2320d8c6a1c3b94e06c9985";

const androidWalletKeyBytes = hex.decode(androidWalletPrivKey);
const androidWalletPrivKeyBytes = androidWalletKeyBytes.subarray(0, 32);
const androidWalletPubKeyBytes = androidWalletKeyBytes.subarray(32);

const passphrase = "asdf1234";

const pemString =
    "-----BEGIN PRIVATE KEY-----\n" +
    "MC4CAQAwBQYDK2VwBCIEINtIS4KOZLLY8SzjwKDpOguMznrxu485yXcyOUSCU44Q\n" +
    "-----END PRIVATE KEY-----\n";

const encryptedPem =
    "-----BEGIN ENCRYPTED PRIVATE KEY-----\n" +
    "MIGbMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAi8WY7Gy2tThQICCAAw\n" +
    "DAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEOq46NPss58chbjUn20NoK0EQG1x\n" +
    "R88hIXcWDOECttPTNlMXWJt7Wufm1YwBibrxmCq1QykIyTYhy1TZMyxyPxlYW6aV\n" +
    "9hlo4YEh3uEaCmfJzWM=\n" +
    "-----END ENCRYPTED PRIVATE KEY-----\n";

const pemPassphrase = "this is a passphrase";

describe("PrivateKey", function () {
    it("should be able to sign message", function () {
        expect(privateKey.sign(message)).to.deep.eq(signature);
    });

    it("should correctly verify signature", function () {
        expect(privateKey.publicKey.verify(message, signature)).to.be.true;
    });

    it("should produce correctly encoded string when toString() is called", function () {
        expect(privateKey.toString()).to.deep.equal(privKeyStr);
    });

    it("should produce same publicKey", function () {
        expect(privateKey.publicKey.toBytesRaw()).to.deep.equal(pubKeyBytes);
    });

    it("should return correct value when using fromString", function () {
        const privateKey = PrivateKey.fromString(privKeyStr);
        expect(privateKey.toBytesRaw()).to.deep.equal(privKeyBytes);

        const privateKey2 = PrivateKey.fromString(privAndPubKeyStr);
        expect(privateKey2.toBytesRaw()).to.deep.equal(privKeyBytes);

        const privateKey3 = PrivateKey.fromString(rawPrivKeyStr);
        expect(privateKey3.toBytesRaw()).to.deep.equal(privKeyBytes);

        const privateKey4 = PrivateKey.fromString(iosWalletPrivKey);
        expect(privateKey4.toBytesRaw()).to.deep.equal(iosWalletPrivKeyBytes);
        expect(privateKey4.publicKey.toBytesRaw()).to.deep.equal(
            iosWalletPubKeyBytes
        );

        const privateKey5 = PrivateKey.fromString(androidWalletPrivKey);
        expect(privateKey5.toBytesRaw()).to.deep.equal(
            androidWalletPrivKeyBytes
        );
        expect(privateKey5.publicKey.toBytesRaw()).to.deep.equal(
            androidWalletPubKeyBytes
        );
    });

    it("toKeystore() creates loadable keystores", async function () {
        const keystoreBytes = await privateKey.toKeystore(passphrase);
        const key = await PrivateKey.fromKeystore(keystoreBytes, passphrase);

        expect(privateKey.toBytes()).to.deep.equal(key.toBytes());

        await PrivateKey.fromKeystore(
            keystoreBytes,
            "some random password"
        ).catch((err) => {
            expect(err).to.be.instanceOf(BadKeyError);
            expect(err).to.have.property(
                "message",
                "HMAC mismatch; passphrase is incorrect"
            );
        });
    });

    it("keystore works correctly", async function () {
        const keystoreBytesFromFile = utf8.encode(keystoreV1);

        const key = await PrivateKey.fromKeystore(
            keystoreBytesFromFile,
            keystorePassword
        );

        expect(privateKeystore).to.deep.equal(key.toString());
    });

    it("derive() produces correct value", async function () {
        const iosMnemonic = await Mnemonic.fromString(iosWalletMnemonic);
        const iosKey = await PrivateKey.fromMnemonic(iosMnemonic, "");
        const iosChildKey = await iosKey.derive(0);

        expect(iosChildKey.toBytesRaw()).to.deep.equal(iosWalletPrivKeyBytes);
        expect(iosChildKey.publicKey.toBytesRaw()).to.deep.equal(
            iosWalletPubKeyBytes
        );

        const androidMnemonic = await Mnemonic.fromString(
            androidWalletMnemonic
        );
        const androidKey = await PrivateKey.fromMnemonic(androidMnemonic, "");
        const androidChildKey = await androidKey.derive(0);

        expect(androidChildKey.toBytesRaw()).to.deep.equal(
            androidWalletPrivKeyBytes
        );
        expect(androidChildKey.publicKey.toBytesRaw()).to.deep.equal(
            androidWalletPubKeyBytes
        );
    });

    it("fromPem() produces a correct value", async function () {
        const key = await PrivateKey.fromPem(pemString);
        expect(key.toString()).to.deep.equal(privKeyStr);
    });

    it("fromPem() with passphrase produces a correct value", async function () {
        const key = await PrivateKey.fromPem(encryptedPem, pemPassphrase);
        expect(key.toString()).to.deep.equal(privKeyStr);
    });

    it("PublicKey.fromString() should work", async function () {
        let err = false;

        try {
            PublicKey.fromString(PrivateKey.generate().publicKey.toString());
        } catch (error) {
            err = true;
        }

        expect(err).to.be.false;
    });
});
